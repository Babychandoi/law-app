{"ast":null,"code":"/**\n * Special values that tell deepmerge to perform a certain action.\n */\nconst actions = {\n  defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n  skip: Symbol(\"deepmerge-ts: skip\")\n};\n/**\n * Special values that tell deepmergeInto to perform a certain action.\n */\nconst actionsInto = {\n  defaultMerge: actions.defaultMerge\n};\n\n/**\n * The default function to update meta data.\n *\n * It doesn't update the meta data.\n */\nfunction defaultMetaDataUpdater(previousMeta, metaMeta) {\n  return metaMeta;\n}\n/**\n * The default function to filter values.\n *\n * It filters out undefined values.\n */\nfunction defaultFilterValues(values, meta) {\n  return values.filter(value => value !== undefined);\n}\n\n/**\n * The different types of objects deepmerge-ts support.\n */\nvar ObjectType;\n(function (ObjectType) {\n  ObjectType[ObjectType[\"NOT\"] = 0] = \"NOT\";\n  ObjectType[ObjectType[\"RECORD\"] = 1] = \"RECORD\";\n  ObjectType[ObjectType[\"ARRAY\"] = 2] = \"ARRAY\";\n  ObjectType[ObjectType[\"SET\"] = 3] = \"SET\";\n  ObjectType[ObjectType[\"MAP\"] = 4] = \"MAP\";\n  ObjectType[ObjectType[\"OTHER\"] = 5] = \"OTHER\";\n})(ObjectType || (ObjectType = {}));\n/**\n * Get the type of the given object.\n *\n * @param object - The object to get the type of.\n * @returns The type of the given object.\n */\nfunction getObjectType(object) {\n  if (typeof object !== \"object\" || object === null) {\n    return 0 /* ObjectType.NOT */;\n  }\n  if (Array.isArray(object)) {\n    return 2 /* ObjectType.ARRAY */;\n  }\n  if (isRecord(object)) {\n    return 1 /* ObjectType.RECORD */;\n  }\n  if (object instanceof Set) {\n    return 3 /* ObjectType.SET */;\n  }\n  if (object instanceof Map) {\n    return 4 /* ObjectType.MAP */;\n  }\n  return 5 /* ObjectType.OTHER */;\n}\n/**\n * Get the keys of the given objects including symbol keys.\n *\n * Note: Only keys to enumerable properties are returned.\n *\n * @param objects - An array of objects to get the keys of.\n * @returns A set containing all the keys of all the given objects.\n */\nfunction getKeys(objects) {\n  const keys = new Set();\n  for (const object of objects) {\n    for (const key of [...Object.keys(object), ...Object.getOwnPropertySymbols(object)]) {\n      keys.add(key);\n    }\n  }\n  return keys;\n}\n/**\n * Does the given object have the given property.\n *\n * @param object - The object to test.\n * @param property - The property to test.\n * @returns Whether the object has the property.\n */\nfunction objectHasProperty(object, property) {\n  return typeof object === \"object\" && Object.prototype.propertyIsEnumerable.call(object, property);\n}\n/**\n * Get an iterable object that iterates over the given iterables.\n */\nfunction getIterableOfIterables(iterables) {\n  let m_iterablesIndex = 0;\n  let m_iterator = iterables[0]?.[Symbol.iterator]();\n  return {\n    [Symbol.iterator]() {\n      return {\n        next() {\n          do {\n            if (m_iterator === undefined) {\n              return {\n                done: true,\n                value: undefined\n              };\n            }\n            const result = m_iterator.next();\n            if (result.done === true) {\n              m_iterablesIndex += 1;\n              m_iterator = iterables[m_iterablesIndex]?.[Symbol.iterator]();\n              continue;\n            }\n            return {\n              done: false,\n              value: result.value\n            };\n          } while (true);\n        }\n      };\n    }\n  };\n}\n// eslint-disable-next-line unicorn/prefer-set-has -- Array is more performant for a low number of elements.\nconst validRecordToStringValues = [\"[object Object]\", \"[object Module]\"];\n/**\n * Does the given object appear to be a record.\n */\nfunction isRecord(value) {\n  // All records are objects.\n  if (!validRecordToStringValues.includes(Object.prototype.toString.call(value))) {\n    return false;\n  }\n  const {\n    constructor\n  } = value;\n  // If has modified constructor.\n  // eslint-disable-next-line ts/no-unnecessary-condition\n  if (constructor === undefined) {\n    return true;\n  }\n  const prototype = constructor.prototype;\n  // If has modified prototype.\n  if (prototype === null || typeof prototype !== \"object\" || !validRecordToStringValues.includes(Object.prototype.toString.call(prototype))) {\n    return false;\n  }\n  // If constructor does not have an Object-specific method.\n  // eslint-disable-next-line sonar/prefer-single-boolean-return, no-prototype-builtins\n  if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  // Most likely a record.\n  return true;\n}\n\n/**\n * The default strategy to merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords$1(values, utils, meta) {\n  const result = {};\n  for (const key of getKeys(values)) {\n    const propValues = [];\n    for (const value of values) {\n      if (objectHasProperty(value, key)) {\n        propValues.push(value[key]);\n      }\n    }\n    if (propValues.length === 0) {\n      continue;\n    }\n    const updatedMeta = utils.metaDataUpdater(meta, {\n      key,\n      parents: values\n    });\n    const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);\n    if (propertyResult === actions.skip) {\n      continue;\n    }\n    if (key === \"__proto__\") {\n      Object.defineProperty(result, key, {\n        value: propertyResult,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      });\n    } else {\n      result[key] = propertyResult;\n    }\n  }\n  return result;\n}\n/**\n * The default strategy to merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays$1(values) {\n  return values.flat();\n}\n/**\n * The default strategy to merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets$1(values) {\n  return new Set(getIterableOfIterables(values));\n}\n/**\n * The default strategy to merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps$1(values) {\n  return new Map(getIterableOfIterables(values));\n}\n/**\n * Get the last non-undefined value in the given array.\n */\nfunction mergeOthers$1(values) {\n  return values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeFunctions = {\n  mergeRecords: mergeRecords$1,\n  mergeArrays: mergeArrays$1,\n  mergeSets: mergeSets$1,\n  mergeMaps: mergeMaps$1,\n  mergeOthers: mergeOthers$1\n};\n\n/**\n * Deeply merge objects.\n *\n * @param objects - The objects to merge.\n */\nfunction deepmerge(...objects) {\n  return deepmergeCustom({})(...objects);\n}\nfunction deepmergeCustom(options, rootMetaData) {\n  const utils = getUtils(options, customizedDeepmerge);\n  /**\n   * The customized deepmerge function.\n   */\n  function customizedDeepmerge(...objects) {\n    return mergeUnknowns(objects, utils, rootMetaData);\n  }\n  return customizedDeepmerge;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getUtils(options, customizedDeepmerge) {\n  return {\n    defaultMergeFunctions: mergeFunctions,\n    mergeFunctions: {\n      ...mergeFunctions,\n      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.hasOwn(mergeFunctions, key)).map(([key, option]) => option === false ? [key, mergeFunctions.mergeOthers] : [key, option]))\n    },\n    metaDataUpdater: options.metaDataUpdater ?? defaultMetaDataUpdater,\n    deepmerge: customizedDeepmerge,\n    useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,\n    filterValues: options.filterValues === false ? undefined : options.filterValues ?? defaultFilterValues,\n    actions\n  };\n}\n/**\n * Merge unknown things.\n *\n * @param values - The values.\n */\nfunction mergeUnknowns(values, utils, meta) {\n  const filteredValues = utils.filterValues?.(values, meta) ?? values;\n  if (filteredValues.length === 0) {\n    return undefined;\n  }\n  if (filteredValues.length === 1) {\n    return mergeOthers(filteredValues, utils, meta);\n  }\n  const type = getObjectType(filteredValues[0]);\n  if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n    for (let m_index = 1; m_index < filteredValues.length; m_index++) {\n      if (getObjectType(filteredValues[m_index]) === type) {\n        continue;\n      }\n      return mergeOthers(filteredValues, utils, meta);\n    }\n  }\n  switch (type) {\n    case 1 /* ObjectType.RECORD */:\n      {\n        return mergeRecords(filteredValues, utils, meta);\n      }\n    case 2 /* ObjectType.ARRAY */:\n      {\n        return mergeArrays(filteredValues, utils, meta);\n      }\n    case 3 /* ObjectType.SET */:\n      {\n        return mergeSets(filteredValues, utils, meta);\n      }\n    case 4 /* ObjectType.MAP */:\n      {\n        return mergeMaps(filteredValues, utils, meta);\n      }\n    default:\n      {\n        return mergeOthers(filteredValues, utils, meta);\n      }\n  }\n}\n/**\n * Merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords) {\n    return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);\n  }\n  return result;\n}\n/**\n * Merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays) {\n    return utils.defaultMergeFunctions.mergeArrays(values);\n  }\n  return result;\n}\n/**\n * Merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets) {\n    return utils.defaultMergeFunctions.mergeSets(values);\n  }\n  return result;\n}\n/**\n * Merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps) {\n    return utils.defaultMergeFunctions.mergeMaps(values);\n  }\n  return result;\n}\n/**\n * Merge other things.\n *\n * @param values - The other things.\n */\nfunction mergeOthers(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers) {\n    return utils.defaultMergeFunctions.mergeOthers(values);\n  }\n  return result;\n}\n\n/**\n * The default strategy to merge records into a target record.\n *\n * @param m_target - The result will be mutated into this record\n * @param values - The records (including the target's value if there is one).\n */\nfunction mergeRecordsInto$1(m_target, values, utils, meta) {\n  for (const key of getKeys(values)) {\n    const propValues = [];\n    for (const value of values) {\n      if (objectHasProperty(value, key)) {\n        propValues.push(value[key]);\n      }\n    }\n    if (propValues.length === 0) {\n      continue;\n    }\n    const updatedMeta = utils.metaDataUpdater(meta, {\n      key,\n      parents: values\n    });\n    const propertyTarget = {\n      value: propValues[0]\n    };\n    mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);\n    if (key === \"__proto__\") {\n      Object.defineProperty(m_target.value, key, {\n        value: propertyTarget.value,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      });\n    } else {\n      m_target.value[key] = propertyTarget.value;\n    }\n  }\n}\n/**\n * The default strategy to merge arrays into a target array.\n *\n * @param m_target - The result will be mutated into this array\n * @param values - The arrays (including the target's value if there is one).\n */\nfunction mergeArraysInto$1(m_target, values) {\n  m_target.value.push(...values.slice(1).flat());\n}\n/**\n * The default strategy to merge sets into a target set.\n *\n * @param m_target - The result will be mutated into this set\n * @param values - The sets (including the target's value if there is one).\n */\nfunction mergeSetsInto$1(m_target, values) {\n  for (const value of getIterableOfIterables(values.slice(1))) {\n    m_target.value.add(value);\n  }\n}\n/**\n * The default strategy to merge maps into a target map.\n *\n * @param m_target - The result will be mutated into this map\n * @param values - The maps (including the target's value if there is one).\n */\nfunction mergeMapsInto$1(m_target, values) {\n  for (const [key, value] of getIterableOfIterables(values.slice(1))) {\n    m_target.value.set(key, value);\n  }\n}\n/**\n * Set the target to the last non-undefined value.\n */\nfunction mergeOthersInto$1(m_target, values) {\n  m_target.value = values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeIntoFunctions = {\n  mergeRecords: mergeRecordsInto$1,\n  mergeArrays: mergeArraysInto$1,\n  mergeSets: mergeSetsInto$1,\n  mergeMaps: mergeMapsInto$1,\n  mergeOthers: mergeOthersInto$1\n};\nfunction deepmergeInto(target, ...objects) {\n  return void deepmergeIntoCustom({})(target, ...objects);\n}\nfunction deepmergeIntoCustom(options, rootMetaData) {\n  const utils = getIntoUtils(options, customizedDeepmergeInto);\n  /**\n   * The customized deepmerge function.\n   */\n  function customizedDeepmergeInto(target, ...objects) {\n    mergeUnknownsInto({\n      value: target\n    }, [target, ...objects], utils, rootMetaData);\n  }\n  return customizedDeepmergeInto;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getIntoUtils(options, customizedDeepmergeInto) {\n  return {\n    defaultMergeFunctions: mergeIntoFunctions,\n    mergeFunctions: {\n      ...mergeIntoFunctions,\n      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.hasOwn(mergeIntoFunctions, key)).map(([key, option]) => option === false ? [key, mergeIntoFunctions.mergeOthers] : [key, option]))\n    },\n    metaDataUpdater: options.metaDataUpdater ?? defaultMetaDataUpdater,\n    deepmergeInto: customizedDeepmergeInto,\n    filterValues: options.filterValues === false ? undefined : options.filterValues ?? defaultFilterValues,\n    actions: actionsInto\n  };\n}\n/**\n * Merge unknown things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The values.\n */\nfunction mergeUnknownsInto(m_target, values, utils, meta) {\n  const filteredValues = utils.filterValues?.(values, meta) ?? values;\n  if (filteredValues.length === 0) {\n    return;\n  }\n  if (filteredValues.length === 1) {\n    return void mergeOthersInto(m_target, filteredValues, utils, meta);\n  }\n  const type = getObjectType(m_target.value);\n  if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n    for (let m_index = 1; m_index < filteredValues.length; m_index++) {\n      if (getObjectType(filteredValues[m_index]) === type) {\n        continue;\n      }\n      return void mergeOthersInto(m_target, filteredValues, utils, meta);\n    }\n  }\n  switch (type) {\n    case 1 /* ObjectType.RECORD */:\n      {\n        return void mergeRecordsInto(m_target, filteredValues, utils, meta);\n      }\n    case 2 /* ObjectType.ARRAY */:\n      {\n        return void mergeArraysInto(m_target, filteredValues, utils, meta);\n      }\n    case 3 /* ObjectType.SET */:\n      {\n        return void mergeSetsInto(m_target, filteredValues, utils, meta);\n      }\n    case 4 /* ObjectType.MAP */:\n      {\n        return void mergeMapsInto(m_target, filteredValues, utils, meta);\n      }\n    default:\n      {\n        return void mergeOthersInto(m_target, filteredValues, utils, meta);\n      }\n  }\n}\n/**\n * Merge records into a target record.\n *\n * @param m_target - The target to merge into.\n * @param values - The records.\n */\nfunction mergeRecordsInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeRecords(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeRecords(m_target, values, utils, meta);\n  }\n}\n/**\n * Merge arrays into a target array.\n *\n * @param m_target - The target to merge into.\n * @param values - The arrays.\n */\nfunction mergeArraysInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeArrays(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeArrays(m_target, values);\n  }\n}\n/**\n * Merge sets into a target set.\n *\n * @param m_target - The target to merge into.\n * @param values - The sets.\n */\nfunction mergeSetsInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeSets(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeSets(m_target, values);\n  }\n}\n/**\n * Merge maps into a target map.\n *\n * @param m_target - The target to merge into.\n * @param values - The maps.\n */\nfunction mergeMapsInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeMaps(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeMaps(m_target, values);\n  }\n}\n/**\n * Merge other things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The other things.\n */\nfunction mergeOthersInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeOthers(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge || m_target.value === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeOthers(m_target, values);\n  }\n}\nexport { deepmerge, deepmergeCustom, deepmergeInto, deepmergeIntoCustom, getKeys, getObjectType, objectHasProperty };","map":{"version":3,"names":["actions","defaultMerge","Symbol","skip","actionsInto","defaultMetaDataUpdater","previousMeta","metaMeta","defaultFilterValues","values","meta","filter","value","undefined","ObjectType","getObjectType","object","Array","isArray","isRecord","Set","Map","getKeys","objects","keys","key","Object","getOwnPropertySymbols","add","objectHasProperty","property","prototype","propertyIsEnumerable","call","getIterableOfIterables","iterables","m_iterablesIndex","m_iterator","iterator","next","done","result","validRecordToStringValues","includes","toString","constructor","hasOwnProperty","mergeRecords$1","utils","propValues","push","length","updatedMeta","metaDataUpdater","parents","propertyResult","mergeUnknowns","defineProperty","configurable","enumerable","writable","mergeArrays$1","flat","mergeSets$1","mergeMaps$1","mergeOthers$1","at","mergeFunctions","mergeRecords","mergeArrays","mergeSets","mergeMaps","mergeOthers","deepmerge","deepmergeCustom","options","rootMetaData","getUtils","customizedDeepmerge","defaultMergeFunctions","fromEntries","entries","option","hasOwn","map","useImplicitDefaultMerging","enableImplicitDefaultMerging","filterValues","filteredValues","type","m_index","mergeRecordsInto$1","m_target","propertyTarget","mergeUnknownsInto","mergeArraysInto$1","slice","mergeSetsInto$1","mergeMapsInto$1","set","mergeOthersInto$1","mergeIntoFunctions","deepmergeInto","target","deepmergeIntoCustom","getIntoUtils","customizedDeepmergeInto","mergeOthersInto","mergeRecordsInto","mergeArraysInto","mergeSetsInto","mergeMapsInto","action"],"sources":["D:/ATWON/law-app/node_modules/deepmerge-ts/dist/index.mjs"],"sourcesContent":["/**\n * Special values that tell deepmerge to perform a certain action.\n */\nconst actions = {\n    defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n    skip: Symbol(\"deepmerge-ts: skip\"),\n};\n/**\n * Special values that tell deepmergeInto to perform a certain action.\n */\nconst actionsInto = {\n    defaultMerge: actions.defaultMerge,\n};\n\n/**\n * The default function to update meta data.\n *\n * It doesn't update the meta data.\n */\nfunction defaultMetaDataUpdater(previousMeta, metaMeta) {\n    return metaMeta;\n}\n/**\n * The default function to filter values.\n *\n * It filters out undefined values.\n */\nfunction defaultFilterValues(values, meta) {\n    return values.filter((value) => value !== undefined);\n}\n\n/**\n * The different types of objects deepmerge-ts support.\n */\nvar ObjectType;\n(function (ObjectType) {\n    ObjectType[ObjectType[\"NOT\"] = 0] = \"NOT\";\n    ObjectType[ObjectType[\"RECORD\"] = 1] = \"RECORD\";\n    ObjectType[ObjectType[\"ARRAY\"] = 2] = \"ARRAY\";\n    ObjectType[ObjectType[\"SET\"] = 3] = \"SET\";\n    ObjectType[ObjectType[\"MAP\"] = 4] = \"MAP\";\n    ObjectType[ObjectType[\"OTHER\"] = 5] = \"OTHER\";\n})(ObjectType || (ObjectType = {}));\n/**\n * Get the type of the given object.\n *\n * @param object - The object to get the type of.\n * @returns The type of the given object.\n */\nfunction getObjectType(object) {\n    if (typeof object !== \"object\" || object === null) {\n        return 0 /* ObjectType.NOT */;\n    }\n    if (Array.isArray(object)) {\n        return 2 /* ObjectType.ARRAY */;\n    }\n    if (isRecord(object)) {\n        return 1 /* ObjectType.RECORD */;\n    }\n    if (object instanceof Set) {\n        return 3 /* ObjectType.SET */;\n    }\n    if (object instanceof Map) {\n        return 4 /* ObjectType.MAP */;\n    }\n    return 5 /* ObjectType.OTHER */;\n}\n/**\n * Get the keys of the given objects including symbol keys.\n *\n * Note: Only keys to enumerable properties are returned.\n *\n * @param objects - An array of objects to get the keys of.\n * @returns A set containing all the keys of all the given objects.\n */\nfunction getKeys(objects) {\n    const keys = new Set();\n    for (const object of objects) {\n        for (const key of [...Object.keys(object), ...Object.getOwnPropertySymbols(object)]) {\n            keys.add(key);\n        }\n    }\n    return keys;\n}\n/**\n * Does the given object have the given property.\n *\n * @param object - The object to test.\n * @param property - The property to test.\n * @returns Whether the object has the property.\n */\nfunction objectHasProperty(object, property) {\n    return typeof object === \"object\" && Object.prototype.propertyIsEnumerable.call(object, property);\n}\n/**\n * Get an iterable object that iterates over the given iterables.\n */\nfunction getIterableOfIterables(iterables) {\n    let m_iterablesIndex = 0;\n    let m_iterator = iterables[0]?.[Symbol.iterator]();\n    return {\n        [Symbol.iterator]() {\n            return {\n                next() {\n                    do {\n                        if (m_iterator === undefined) {\n                            return { done: true, value: undefined };\n                        }\n                        const result = m_iterator.next();\n                        if (result.done === true) {\n                            m_iterablesIndex += 1;\n                            m_iterator = iterables[m_iterablesIndex]?.[Symbol.iterator]();\n                            continue;\n                        }\n                        return {\n                            done: false,\n                            value: result.value,\n                        };\n                    } while (true);\n                },\n            };\n        },\n    };\n}\n// eslint-disable-next-line unicorn/prefer-set-has -- Array is more performant for a low number of elements.\nconst validRecordToStringValues = [\"[object Object]\", \"[object Module]\"];\n/**\n * Does the given object appear to be a record.\n */\nfunction isRecord(value) {\n    // All records are objects.\n    if (!validRecordToStringValues.includes(Object.prototype.toString.call(value))) {\n        return false;\n    }\n    const { constructor } = value;\n    // If has modified constructor.\n    // eslint-disable-next-line ts/no-unnecessary-condition\n    if (constructor === undefined) {\n        return true;\n    }\n    const prototype = constructor.prototype;\n    // If has modified prototype.\n    if (prototype === null ||\n        typeof prototype !== \"object\" ||\n        !validRecordToStringValues.includes(Object.prototype.toString.call(prototype))) {\n        return false;\n    }\n    // If constructor does not have an Object-specific method.\n    // eslint-disable-next-line sonar/prefer-single-boolean-return, no-prototype-builtins\n    if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n        return false;\n    }\n    // Most likely a record.\n    return true;\n}\n\n/**\n * The default strategy to merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords$1(values, utils, meta) {\n    const result = {};\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);\n        if (propertyResult === actions.skip) {\n            continue;\n        }\n        if (key === \"__proto__\") {\n            Object.defineProperty(result, key, {\n                value: propertyResult,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            result[key] = propertyResult;\n        }\n    }\n    return result;\n}\n/**\n * The default strategy to merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays$1(values) {\n    return values.flat();\n}\n/**\n * The default strategy to merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets$1(values) {\n    return new Set(getIterableOfIterables(values));\n}\n/**\n * The default strategy to merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps$1(values) {\n    return new Map(getIterableOfIterables(values));\n}\n/**\n * Get the last non-undefined value in the given array.\n */\nfunction mergeOthers$1(values) {\n    return values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeFunctions = {\n    mergeRecords: mergeRecords$1,\n    mergeArrays: mergeArrays$1,\n    mergeSets: mergeSets$1,\n    mergeMaps: mergeMaps$1,\n    mergeOthers: mergeOthers$1,\n};\n\n/**\n * Deeply merge objects.\n *\n * @param objects - The objects to merge.\n */\nfunction deepmerge(...objects) {\n    return deepmergeCustom({})(...objects);\n}\nfunction deepmergeCustom(options, rootMetaData) {\n    const utils = getUtils(options, customizedDeepmerge);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmerge(...objects) {\n        return mergeUnknowns(objects, utils, rootMetaData);\n    }\n    return customizedDeepmerge;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getUtils(options, customizedDeepmerge) {\n    return {\n        defaultMergeFunctions: mergeFunctions,\n        mergeFunctions: {\n            ...mergeFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmerge: customizedDeepmerge,\n        useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions,\n    };\n}\n/**\n * Merge unknown things.\n *\n * @param values - The values.\n */\nfunction mergeUnknowns(values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return undefined;\n    }\n    if (filteredValues.length === 1) {\n        return mergeOthers(filteredValues, utils, meta);\n    }\n    const type = getObjectType(filteredValues[0]);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let m_index = 1; m_index < filteredValues.length; m_index++) {\n            if (getObjectType(filteredValues[m_index]) === type) {\n                continue;\n            }\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return mergeRecords(filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return mergeArrays(filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return mergeSets(filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return mergeMaps(filteredValues, utils, meta);\n        }\n        default: {\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords)) {\n        return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);\n    }\n    return result;\n}\n/**\n * Merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays)) {\n        return utils.defaultMergeFunctions.mergeArrays(values);\n    }\n    return result;\n}\n/**\n * Merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets)) {\n        return utils.defaultMergeFunctions.mergeSets(values);\n    }\n    return result;\n}\n/**\n * Merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps)) {\n        return utils.defaultMergeFunctions.mergeMaps(values);\n    }\n    return result;\n}\n/**\n * Merge other things.\n *\n * @param values - The other things.\n */\nfunction mergeOthers(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers)) {\n        return utils.defaultMergeFunctions.mergeOthers(values);\n    }\n    return result;\n}\n\n/**\n * The default strategy to merge records into a target record.\n *\n * @param m_target - The result will be mutated into this record\n * @param values - The records (including the target's value if there is one).\n */\nfunction mergeRecordsInto$1(m_target, values, utils, meta) {\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyTarget = { value: propValues[0] };\n        mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);\n        if (key === \"__proto__\") {\n            Object.defineProperty(m_target.value, key, {\n                value: propertyTarget.value,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            m_target.value[key] = propertyTarget.value;\n        }\n    }\n}\n/**\n * The default strategy to merge arrays into a target array.\n *\n * @param m_target - The result will be mutated into this array\n * @param values - The arrays (including the target's value if there is one).\n */\nfunction mergeArraysInto$1(m_target, values) {\n    m_target.value.push(...values.slice(1).flat());\n}\n/**\n * The default strategy to merge sets into a target set.\n *\n * @param m_target - The result will be mutated into this set\n * @param values - The sets (including the target's value if there is one).\n */\nfunction mergeSetsInto$1(m_target, values) {\n    for (const value of getIterableOfIterables(values.slice(1))) {\n        m_target.value.add(value);\n    }\n}\n/**\n * The default strategy to merge maps into a target map.\n *\n * @param m_target - The result will be mutated into this map\n * @param values - The maps (including the target's value if there is one).\n */\nfunction mergeMapsInto$1(m_target, values) {\n    for (const [key, value] of getIterableOfIterables(values.slice(1))) {\n        m_target.value.set(key, value);\n    }\n}\n/**\n * Set the target to the last non-undefined value.\n */\nfunction mergeOthersInto$1(m_target, values) {\n    m_target.value = values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeIntoFunctions = {\n    mergeRecords: mergeRecordsInto$1,\n    mergeArrays: mergeArraysInto$1,\n    mergeSets: mergeSetsInto$1,\n    mergeMaps: mergeMapsInto$1,\n    mergeOthers: mergeOthersInto$1,\n};\n\nfunction deepmergeInto(target, ...objects) {\n    return void deepmergeIntoCustom({})(target, ...objects);\n}\nfunction deepmergeIntoCustom(options, rootMetaData) {\n    const utils = getIntoUtils(options, customizedDeepmergeInto);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmergeInto(target, ...objects) {\n        mergeUnknownsInto({ value: target }, [target, ...objects], utils, rootMetaData);\n    }\n    return customizedDeepmergeInto;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getIntoUtils(options, customizedDeepmergeInto) {\n    return {\n        defaultMergeFunctions: mergeIntoFunctions,\n        mergeFunctions: {\n            ...mergeIntoFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeIntoFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeIntoFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmergeInto: customizedDeepmergeInto,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions: actionsInto,\n    };\n}\n/**\n * Merge unknown things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The values.\n */\nfunction mergeUnknownsInto(m_target, values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return;\n    }\n    if (filteredValues.length === 1) {\n        return void mergeOthersInto(m_target, filteredValues, utils, meta);\n    }\n    const type = getObjectType(m_target.value);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let m_index = 1; m_index < filteredValues.length; m_index++) {\n            if (getObjectType(filteredValues[m_index]) === type) {\n                continue;\n            }\n            return void mergeOthersInto(m_target, filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return void mergeRecordsInto(m_target, filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return void mergeArraysInto(m_target, filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return void mergeSetsInto(m_target, filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return void mergeMapsInto(m_target, filteredValues, utils, meta);\n        }\n        default: {\n            return void mergeOthersInto(m_target, filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records into a target record.\n *\n * @param m_target - The target to merge into.\n * @param values - The records.\n */\nfunction mergeRecordsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeRecords(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeRecords(m_target, values, utils, meta);\n    }\n}\n/**\n * Merge arrays into a target array.\n *\n * @param m_target - The target to merge into.\n * @param values - The arrays.\n */\nfunction mergeArraysInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeArrays(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeArrays(m_target, values);\n    }\n}\n/**\n * Merge sets into a target set.\n *\n * @param m_target - The target to merge into.\n * @param values - The sets.\n */\nfunction mergeSetsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeSets(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeSets(m_target, values);\n    }\n}\n/**\n * Merge maps into a target map.\n *\n * @param m_target - The target to merge into.\n * @param values - The maps.\n */\nfunction mergeMapsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeMaps(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeMaps(m_target, values);\n    }\n}\n/**\n * Merge other things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The other things.\n */\nfunction mergeOthersInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeOthers(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge || m_target.value === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeOthers(m_target, values);\n    }\n}\n\nexport { deepmerge, deepmergeCustom, deepmergeInto, deepmergeIntoCustom, getKeys, getObjectType, objectHasProperty };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}